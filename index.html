<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>netvr</title>

    <script src="https://www.unpkg.com/jquery@3.6.0/dist/jquery.min.js" type="text/javascript"></script>

    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js" type="text/javascript"></script>

    <script src="https://unpkg.com/worldwindjs@1.8.0/build/dist/worldwind.min.js" type="text/javascript"></script>

    <!--
    OSM Tags
      https://taginfo.openstreetmap.org/download
      https://wiki.openstreetmap.org/wiki/Category:Tag_descriptions
    -->
    <script src="https://unpkg.com/osmtogeojson@3.0.0-beta.4/osmtogeojson.js" type="text/javascript"></script>

    <!-- https://packery.metafizzy.co/ -->
<!--    <script src="https://unpkg.com/packery@2.1.2/dist/packery.pkgd.min.js" type="text/javascript"></script>-->

<!--    <script src="http://kombai.github.io/freewall/freewall.js" type="text/javascript"></script>-->
<!--    <link rel="stylesheet" href="http://kombai.github.io/freewall/example/css/style.css"/>-->

    <!-- https://forkaweso.me/Fork-Awesome/icons/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css" integrity="sha256-XoaMnoYC5TH6/+ihMEnospgm0J1PM/nioxbOUdnM8HY=" crossorigin="anonymous">



    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.18.2/cytoscape.min.js" type="text/javascript"></script>-->

    <style>
        body {
            background-color: black;
            font-size: 150%;
            font-family: monospace;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            position: fixed;
        }
        div {
            transition: 0.25s;
            /*opacity: 0.5;*/
        }
        /*div:hover {*/
        /*    opacity: 1.0;*/
        /*}*/

        .full {
            position: fixed; width: 100%; height: 100%; margin: 0; padding: 0;
        }
        .side {
            position: fixed; width: 25%; height: 100%; margin: 0; padding: 0;
        }
        #mode_menu {
            color: white;
        }

        #mode_raw {
            max-height: 12em;
            overflow: scroll;
        }

        #mode_idiocracy button {
            margin: 1em;
            /*opacity:0.75;*/
            pointer-events:painted;
        }
        /*#addmenu {*/
        /*    position: fixed;*/
        /*    left:10%;*/
        /*    top:10%;*/
        /*    width:80%;*/
        /*    height:80%;*/
        /*}*/

        #active {
            height: 100%;
            overflow: auto;
        }
        #active .cell {
            background-color: rgba(0.5, 0.5, 0.5, 0.5);
            color: #bbb;

            /*opacity:0.9;*/
            width: auto;

            padding: 0.1em;
            margin: 0.1em;

            /*min-width: 25px;*/
        }
        #active .cell_enabled {
            background-color: rgba(0.6, 0.6, 0.6, 0.8) !important;
            color: orange;
        }

    </style>

<!--    <script src="https://code.jquery.com/mobile/1.5.0-rc1/jquery.mobile-1.5.0-rc1.min.js" type="text/javascript"></script>-->
<!--    <link rel="stylesheet" href="https://code.jquery.com/mobile/1.5.0-rc1/jquery.mobile-1.5.0-rc1.min.css">-->

</head>
<body>
    <canvas id="map" class="full">
        HTML5 Canvas Unsupported
    </canvas>
    <!-- TODO mode select -->

    <!-- TODO raw amenity mode -->


    <div id="addmenu" style="display:none">
        <div id="mode_menu">
            <button title="Clear"><i class="fa fa-times" aria-hidden="true"></i></button>
            <button title="Amenity"><i class="fa fa-wrench" aria-hidden="true"></i></button>
            <button title="Idiocracy"><i class="fa fa-trophy" aria-hidden="true"></i></button>
        </div>
        <div id="mode_raw">
        </div>
        <div id="mode_idiocracy">
            <button>fuck</button>
            <button>shit</button>
            <button>play</button>
            <button>slep</button>
            <button>eaat</button>
        </div>
    </div>

    <!-- idiocracy mode -->
    <div id="root" class="side">
        <div id="menu" style="position: absolute; left:100%; height: 100%">
            <button id="addmenu_toggle" title="add">+</button>
            <button id="remembermenu_toggle" title="remember">s</button>
        </div>
        <div id="active">
        </div>
    </div>



<script>
    "use strict";

    class Layer {
        constructor(name) {
            this.name = name;
            this.element = $('<div>');
        }

        start(focus) {
            const e = this.element;
            e.attr('class', 'cell').append(this.icon(focus));
            $('#active').append(e);
        }

        stop(focus) {
            $('#active').remove(this.element);
        }

        update(focus) {
            //
        }

        enable() {
            if (this.enabled!==true) {
                this.enabled = true;
                this.element.addClass('cell_enabled');
            }
            return this;
        }

        disable() {
            if (this.enabled!==false) {
                this.enabled = false;
                this.element.removeClass('cell_enabled');
            }
            return this;
        }

        /* produce an element for display in list */
        icon(focus) {
            return $('<button>').text(this.name);
        }
    }

    class WWLayer extends Layer {

        constructor(name, l) {
            super(name);
            this.l = l;
        }
        //TODO set opacity ...

        opacity(o) {
            this.l.opacity = o;
            return this;
        }

        start(focus) {
            super.start(focus);
            focus.view.addLayer(this.l);
            focus.view.redraw(); //TODO debounce
        }
        stop(focus) {
            super.stop(focus);
            focus.view.removeLayer(this.l);
            focus.view.redraw(); //TODO debounce
        }

        enable() {
            super.enable();
            this.l.enabled = true;
            return this;
        }

        disable() {
            super.disable();
            this.l.enabled = false;
            return this;
        }

        icon(focus) {
            const layer = this.l;

            const toggleLabel = () => layer.enabled ? "+" : "-";
            const toggle = $('<button>').text(toggleLabel());
            toggle.click(() => {
                if (layer.enabled) this.disable(); else this.enable();
                toggle.text(toggleLabel());
                focus.view.redraw();
            });

            const label = $('<span>').text(this.name);

            return $('<div>').append(toggle, label);
        }
    }

    class OSMNodes  {

        constructor(focus) {

            this.focus = focus;
            const layers = [];
            this.layers = layers;

            const attr = new WorldWind.PlacemarkAttributes(null);
            attr.imageSource = WorldWind.configuration.baseUrl + "images/white-dot.png";
            attr.imageScale = 0.25;
            attr.imageColor = WorldWind.Color.WHITE;
            attr.labelAttributes.offset = new WorldWind.Offset(
                WorldWind.OFFSET_FRACTION, 0.5,
                WorldWind.OFFSET_FRACTION, 1.5);

            this.shapeConfigurationCallback = (geometry, properties) => {
                const configuration = {};

                // _.forEach(properties, (k,p) => {
                //     console.log(p);
                //     //console.log(p.amenity);
                // });

                if (geometry.isPointType() || geometry.isMultiPointType()) {
                    const v = new WorldWind.PlacemarkAttributes(attr);

                    const amenity = properties.amenity;
                    if (amenity) {
                        if (amenity === 'post_box')
                            v.imageColor = WorldWind.Color.BLUE;
                        else if (amenity === 'bank')
                            v.imageColor = WorldWind.Color.GREEN;
                        else
                            v.imageColor = WorldWind.Color.RED;
                    }
                    //v.imageColor = JSON.toString(properties).hash
                    configuration.attributes = v;

                    if (properties && (properties.name || properties.Name || properties.NAME)) {
                        configuration.name = properties.name || properties.Name || properties.NAME;
                    }
                    // if (properties && properties.POP_MAX) {
                    //     const population = properties.POP_MAX;
                    //     configuration.attributes.imageScale = 0.01 * Math.log(population);
                    // }
                } else if (geometry.isLineStringType() || geometry.isMultiLineStringType()) {
                    configuration.attributes = new WorldWind.ShapeAttributes(null);
                    configuration.attributes.drawOutline = true;
                    configuration.attributes.interiorColor = new WorldWind.Color(
                        0.375 + 0.5 * Math.random(),
                        0.375 + 0.5 * Math.random(),
                        0.375 + 0.5 * Math.random(),
                        1.0);

                    //configuration.attributes.outlineWidth = 2.0;
                } else if (geometry.isPolygonType() || geometry.isMultiPolygonType()) {
                    configuration.attributes = new WorldWind.ShapeAttributes(null);
                    configuration.attributes.drawOutline = false;

                    // Fill the polygon with a random pastel color.
                    configuration.attributes.interiorColor = new WorldWind.Color(
                        0.375 + 0.5 * Math.random(),
                        0.375 + 0.5 * Math.random(),
                        0.375 + 0.5 * Math.random(),
                        0.9);
                    // Paint the outline in a darker variant of the interior color.
                    // configuration.attributes.outlineColor = new WorldWind.Color(
                    //     0.5 * configuration.attributes.interiorColor.red,
                    //     0.5 * configuration.attributes.interiorColor.green,
                    //     0.5 * configuration.attributes.interiorColor.blue,
                    //     1.0);
                }

                return configuration;
            };


        }


        update(query, lat, lon, lonHalf, latHalf) {
            if (!latHalf)
                latHalf = lonHalf; //TODO based on latitude

            //TODO dither these numbers to maximize cache hit rates:
            const latMin = lat - latHalf, latMax = lat + latHalf;
            const lonMin = lon - lonHalf, lonMax = lon + lonHalf;
            let bbox = this.bbox(latMin, lonMin, latMax, lonMax);
            $.ajax({
                /*    query =
                         "<type>\n" +
                         "  <query>\n" +
                         "  (<latMin>, <lonMin>, <latMax>, <lonMax>);\n" +
                         "out;"
                 */
                url: 'https://overpass-api.de/api/interpreter?data='
                    + encodeURIComponent(
                        '[out:json];\n' +
                        query.replaceAll('<bbox>',bbox) +
                        '\nout geom' + bbox + ';'
                        /*
                        area[name="London"]["wikipedia"="en:London"]->.area_of_interest;
                        (
                          node(area.area_of_interest);
                          way(area.area_of_interest);
                          node(w);
                        );
                         */
                    )
            }).done(X => this.addLayer(X));
        }

        bbox(latMin, lonMin, latMax, lonMax) {
            return '(' + latMin + ',' + lonMin + ',' + latMax + ',' + lonMax + ')';
        }

        addLayer(X) {

            const that = this;
            //console.log(X);
            const x = osmtogeojson(X);



            let features = x.features;

            features = _.filter(features, (z)=>{
                return z.properties.amenity || (z.geometry.type==='Polygon' ||z.geometry.type==='LineString');
            });

            //console.log(features);

            const xx = _.groupBy(features, a => {
                if (a.properties && a.properties.amenity)
                    return a.properties.amenity;

                return 'Other';
            });
            _.forEach(xx, (features, amenity)=>{
                const y = _.clone(x);
                y.features = features;
                that.load(y, amenity)
            });

        }

        load(x, name) {
            const y = new WorldWind.RenderableLayer();

            new WorldWind.GeoJSONParser(x).load(null, this.shapeConfigurationCallback, y);

            const Y = new WWLayer(name, y).disable();

            this.layers.push(Y);

            this.focus.addLayer(Y);

            return Y;
        }

        stop(focus) {
            _.forEach(this.layers, focus.removeLayer);
            delete this.layers;
        }
    }

    class Focus {

        constructor(view) {
            this.view = view;

            //TODO w.clearLayers()
            view.addLayer(new WorldWind.AtmosphereLayer());
            //view.addLayer(new WorldWind.CompassLayer());
            //view.addLayer(new WorldWind.CoordinatesDisplayLayer(wwd));
            view.addLayer(new WorldWind.ViewControlsLayer(view));


            this.layers = [];

            const updatePeriodMS = 200;
            setInterval(this.run, updatePeriodMS);
        }

        run() {
            _.forEach(this.layers, (x)=>{
               x.update(this);
            });
        }

        position(lat, lon, alt) {
            const cam = this.cam();
            const pos = cam.position;
            if (!lat)
                return pos;

            cam.tilt = 45;
            pos.latitude = lat;
            pos.longitude = lon;
            pos.altitude = alt;
        }

        cam() {
            return this.view.camera;
        }

        addLayer(layer) {
            this.layers.push(layer);

            if (layer.enabled===undefined)
                layer.enable(); //default state

            layer.start(this);

        }

        removeLayer(layer) {
            layer.element.remove();
            delete layer.element;

            const removed = this.layers.remove(layer);
            console.log(layer, ' = ? = ', removed); //TODO
            layer.stop(this);
        }


    }


    window.addEventListener("load", () => {

        //console.log(WorldWind.configuration);
        WorldWind.configuration.gpuCacheSize = 1e9; // 1gb
        WorldWind.Logger.setLoggingLevel(WorldWind.Logger.LEVEL_WARNING);



        const w = new WorldWind.WorldWindow("map");

        const f = new Focus(w);
        f.position(40.7638, -73.98584, 1000);  //central park

        f.addLayer(new WWLayer("OSM", new WorldWind.OpenStreetMapImageLayer())/*.opacity(0.5)*/);
        f.addLayer(new WWLayer("Satellite", new WorldWind.BingAerialWithLabelsLayer()).disable());
        //f.addLayer(new WWLayer("BMGNOne", new WorldWind.BMNGOneImageLayer()).disable());

        const pos = f.position();
        // new OSMNodes(f).update('node[amenity]<bbox>;',
        //     pos.latitude, pos.longitude, (40.78568 - 40.7638) / 2);
        new OSMNodes(f).update(
            //'(way[highway]<bbox>; relation<bbox>; node<bbox>;);'
            '(way<bbox>; node<bbox>;);'
            ,pos.latitude, pos.longitude, (40.78568 - 40.7638) / 8)

        $("#addmenu_toggle").click(()=>{
            $("#addmenu").toggle(/*"slow"*/);
        });

        {
            $.ajax({
                url: 'osm.tags.popular.json',
            }).done(tags => {
                const raw = $('#mode_raw');
               _.forEach(tags.data, tag=>{
                   const key = tag.key, value = tag.value;

                   //filters
                   if (key === 'source' || key === 'source_ref' || key === 'import_uuid'
                       || key === 'FIXME' || key === 'fixme' || key === 'start_date' || key === 'gauge' || key === 'note'
                       || key === 'attribution' || key === 'mapper'
                   )
                       return;

                   raw.append($('<button>').append(key + '=' + value));
               });
            });
        }


        // var cy = cytoscape({
        //
        //     container: document.getElementById('root'), // container to render in
        //
        //     elements: [ // list of graph elements to start with
        //         {data: { id: 'fuck' }},
        //         {data: { id: 'shit' }},
        //         {data: { id: 'play' }},
        //         {data: { id: 'sleep' }},
        //         {data: { id: 'eat' }}
        //         /*,
        //         {
        //             data: { id: 'ab', source: 'a', target: 'b' }
        //         }*/
        //     ],
        //
        //     style: [ // the stylesheet for the graph
        //         {
        //             selector: 'node',
        //             style: {
        //                 'background-color': '#666',
        //                 'label': 'data(id)'
        //             }
        //         },
        //
        //         {
        //             selector: 'edge',
        //             style: {
        //                 'width': 3,
        //                 'line-color': '#ccc',
        //                 'target-arrow-color': '#ccc',
        //                 'target-arrow-shape': 'triangle',
        //                 'curve-style': 'bezier'
        //             }
        //         }
        //     ],
        //
        //     layout: {
        //         name: 'cose',
        //         rows: 2
        //     }
        //
        // });
        // cy.userPanningEnabled( false );
        // cy.boxSelectionEnabled( false );
        // cy.removeListener('tap');

    }, false);

</script>
</body>
</html>
