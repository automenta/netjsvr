<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>netvr</title>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" type="text/javascript" async></script>

    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js" type="text/javascript" async></script>

    <script src="https://cdn.jsdelivr.net/npm/worldwindjs@1.8.0/build/dist/worldwind.min.js" type="text/javascript"
            async></script>

    <!--
    OSM Tags
      https://taginfo.openstreetmap.org/download
      https://wiki.openstreetmap.org/wiki/Category:Tag_descriptions
    -->
    <script src="https://unpkg.com/osmtogeojson@3.0.0-beta.4/osmtogeojson.js" type="text/javascript" async></script>

    <!-- https://packery.metafizzy.co/ -->
    <!--    <script src="https://unpkg.com/packery@2.1.2/dist/packery.pkgd.min.js" type="text/javascript"></script>-->

    <!--    <script src="https://kombai.github.io/freewall/freewall.js" type="text/javascript"></script>-->
    <!--    <link rel="stylesheet" href="https://kombai.github.io/freewall/example/css/style.css"/>-->

    <!-- https://forkaweso.me/Fork-Awesome/icons/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css"
          integrity="sha256-XoaMnoYC5TH6/+ihMEnospgm0J1PM/nioxbOUdnM8HY=" crossorigin="anonymous">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/js/toastr.min.js" async></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/css/toastr.min.css"/>


    <script async src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"
            type="text/javascript"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.18.2/cytoscape.min.js"
            type="text/javascript"></script>

    <style>
        body {
            background-color: black;
            font-size: 150%;
            font-family: monospace;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            position: fixed;
        }

        div {
            /*transition: 0.25s;*/
        }

        /*div:hover {*/
        /*    opacity: 1.0;*/
        /*}*/

        body:not(.sideExpanded) .content {
            position: fixed;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body.sideExpanded .content {
            position: fixed;
            right: 0;
            width: 75%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body.sideExpanded .side {
            position: fixed;
            width: 25%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body:not(.sideExpanded) .side {
            width: 0;
        }

        body:not(.sideExpanded) .side #active {
            display: none;
        }

        #mode_menu {
            color: white;
        }


        #mode_idiocracy button {
            margin: 1em;
            /*opacity:0.75;*/
            /*pointer-events:painted;*/
        }

        /*#addmenu {*/
        /*    position: fixed;*/
        /*    left:10%;*/
        /*    top:10%;*/
        /*    width:80%;*/
        /*    height:80%;*/
        /*}*/

        #active {
            height: 100%;
            overflow: auto;
            direction: rtl;
            /*opacity: 0.9;*/
            /*display: flow;*/
        }

        #active * {
            direction: ltr; /* restore direction */
        }

        .cell {
            /*background-color: rgba(0.7, 0.7, 0.7, 0.75);*/
            background-color: black;

            color: white;

            /*opacity:0.9;*/
            width: auto;

            padding: 0.1em;
            margin: 0.2em;

            /*min-width: 25px;*/
            border: 4px solid black;
        }

        .cell.cell_enabled {
            /*background-color: rgba(1, 1, 1, 0.9) !important;*/
            padding-top: 0.5em;
            padding-bottom: 0.5em;
            border-color: yellow;

        }

        .cell .label {
            float: left;
            clear: both;
        }

        .cell .controls {
            font-size: 90%;
            padding: 1em;
        }

        .buttonlike {
            cursor: pointer;
            color: white;
            /*background-color: black;*/
            min-height: 1em;
            min-width: 1em;
            vertical-align: central;
            border: solid 0.05em transparent;
        }

        .buttonlike:hover {
            color: darkorange;
            border-color: orange;
        }

        .buttonlike:active {
            color: gold;
            border-color: gold;
        }

        .buttonlike select {
            color: white;
            background-color: black;
            border-color: transparent;
            /*font-size: 50%;*/
        }
        .buttonlike select:hover {
            border-color:orange;
        }

        #menu {
            position: absolute;
            left: 100%;
            height: 100%;
        }

        body:not(.sideExpanded) * #menu {
            left: auto !important;
        }

        /* dat.gui overrides */
        .close-button {
            display: none !important;
        }

        .dg {
            /*font: 11px 'Lucida Grande', sans-serif; */
            font: inherit !important;
            text-shadow: none !important;
        }

        .interestIcon {
            padding: 0.25em;
            font-size: 150%;
        }

    </style>

    <!--    <script src="https://code.jquery.com/mobile/1.5.0-rc1/jquery.mobile-1.5.0-rc1.min.js" type="text/javascript"></script>-->
    <!--    <link rel="stylesheet" href="https://code.jquery.com/mobile/1.5.0-rc1/jquery.mobile-1.5.0-rc1.min.css">-->

</head>
<body class="sideExpanded">

<canvas id="map" class="content">
    HTML5 Canvas Unsupported
</canvas>
<!-- TODO mode select -->

<!-- TODO raw amenity mode -->


<div id="addmenu" style="display:none">
    <div id="mode_menu">
        <button title="Clear"><i class="fa fa-times" aria-hidden="true"></i></button>
        <button title="Amenity"><i class="fa fa-wrench" aria-hidden="true"></i></button>
        <button title="Idiocracy"><i class="fa fa-trophy" aria-hidden="true"></i></button>
    </div>
    <div id="mode_idiocracy">
        <button>fuck</button>
        <button>shit</button>
        <button>play</button>
        <button>slep</button>
        <button>eaat</button>
    </div>
</div>

<!-- idiocracy mode -->
<div id="root" class="side">
    <div id="menu">
        <div id="side_toggle" title="add" class="buttonlike">X</div>
        <div id="addmenu_toggle" title="add" class="buttonlike">+</div>
        <div id="remembermenu_toggle" title="remember" class="buttonlike">s</div>
    </div>
    <div id="active">
        <div id="layers">
        </div>
        <div id="interests" style="min-height: 400px;">
        </div>
        <div id="options">
        </div>
    </div>
</div>


<script>
    "use strict";

    class Layer {
        constructor(name) {
            this.name = name;
            this.layerIconHolder = $('<div>');
            this.enabled = undefined;
        }

        start(focus) {
            const e = this.layerIconHolder;
            e.attr('class', 'cell').append(this.layerIcon(focus));
            $('#layers').append(e);
        }

        stop(focus) {
            //$('#layers').remove(this.layerIconHolder);
            this.layerIconHolder.remove();
        }

        update(focus) {
            //
        }

        set enabled(e) {
            if (this._enabled !== e) {
                this._enabled = e;
                const ele = this.layerIconHolder;
                if (ele) {
                    if (e) ele.addClass('cell_enabled');
                    else ele.removeClass('cell_enabled');
                }
            }
        }

        get enabled() {
            return this._enabled;
        }

        enable() {
            this.enabled = true;
            return this;
        }

        disable() {
            this.enabled = false;
            return this;
        }

        /* produce an element for display in list */
        layerIcon(focus) {
            return $('<button>').text(this.name);
        }
    }

    class HomeLayer extends Layer {
        constructor() {
            super('Home');
            this.label = $('<div>');
        }

        load() {
            try {
                this.pos = JSON.parse(localStorage.home);
                this.label.text(JSON.stringify(this.pos));
            } catch (e) {
                this.pos = undefined;
                delete localStorage.home; //corrupt?
            }
        }

        save() {
            localStorage.home = JSON.stringify(this.pos);
            this.load();
        }

        layerIcon(focus) {
            if (!this.pos) {
                this.load();
                this.go(focus);
            }

            const d = $('<div>');
            d.append('<i class="buttonlike fa fa-home" style="font-size: 200%; float: left;"/>');
            d.append(this.label);
            d.append($('<div>').text('Go').addClass('buttonlike').click(() => {
                this.go(focus);
            }));
            d.append($('<div>').text('Set').addClass('buttonlike').click(() => {
                this.pos = _.clone(focus.view.camera.position);
                this.save();
            }));
            //load(focus.home);
            return d;
        }

        go(focus) {
            if (this.pos) {
                focus.position(this.pos.latitude, this.pos.longitude, this.pos.altitude);
                focus.view.redraw();
            }
        }
    }

    class WWLayer extends Layer {

        constructor(name, l) {
            super(name);
            this.l = l;
        }

        //TODO set opacity ...

        opacity(o) {
            this.l.opacity = o;
            return this;
        }

        start(focus) {
            super.start(focus);
            focus.view.addLayer(this.l);

            //focus.view.redraw(); //TODO debounce
        }

        stop(focus) {
            super.stop(focus);
            focus.view.removeLayer(this.l);
            //focus.view.redraw(); //TODO debounce
        }

        enable() {
            super.enable();
            this.l.enabled = true;
            return this;
        }

        disable() {
            super.disable();
            this.l.enabled = false;
            return this;
        }

        layerIcon(focus) {
            const layer = this.l;

            const toggleLabel = () => (layer.enabled ? "+" : "-") + this.name;

            const label = $('<div>')
                .addClass('label')
                .addClass('buttonlike')
                .attr('style', 'text-align: left;')
                .text(toggleLabel());

            const enablement = () => {
                label.text(toggleLabel());
            };

            enablement(); //initialize

            label.click(() => {
                if (layer.enabled) this.disable(); else this.enable();
                enablement();
                focus.view.redraw();
            });


            //https://github.com/dataarts/dat.gui/blob/master/API.md
            const gui = new dat.GUI({
                name: 'xyz', autoPlace: false, hideable: false,
                width: 'auto'
            });

            const person = {name: 'wtf', age: 45, alive: false};
            gui.add(person, 'name'); // string control

            gui.add(person, 'age', 0, 100); // Add a number controller slider.

            gui.add(person, 'alive');

            const folder1 = gui.addFolder('Flow Field');
            const palette = {
                color1: '#FF0000', // CSS string
                color2: [0, 128, 255], // RGB array
                color3: [0, 128, 255, 0.3], // RGB with alpha
                color4: {h: 350, s: 0.9, v: 0.3} // Hue, saturation, value
            };
            gui.addColor(palette, 'color1');
            gui.addColor(palette, 'color2');
            gui.addColor(palette, 'color3');
            gui.addColor(palette, 'color4');

            // const emotions = $('<div>').append(
            //     '+- = 0'
            // );
            //
            // const display = $('<div>').append(
            //     'opacity = 100%'
            // );

            const controls = $('<div>').addClass('controls').hide().append(
                gui.domElement
            );

            const expander = $('<div>').addClass('buttonlike')
                .text('â‡…').attr('style', 'text-align: right').click(() => {
                    controls.toggle();
                });

            return $('<div>').append(label, expander, controls);
        }
    }

    class OSMNodes {

        constructor(focus) {

            this.focus = focus;
            this.layer = new WorldWind.RenderableLayer();
            this.focus.view.addLayer(this.layer);

            // const attr = new WorldWind.PlacemarkAttributes(null);
            // attr.imageSource = WorldWind.configuration.baseUrl + "images/white-dot.png";
            // attr.imageScale = 0.25;
            // attr.imageColor = WorldWind.Color.WHITE;
            // attr.labelAttributes.offset = new WorldWind.Offset(
            //     WorldWind.OFFSET_FRACTION, 0.5,
            //     WorldWind.OFFSET_FRACTION, 1.5);

            this.shapeConfigurationCallback = (geometry, properties) => {
                const cfg = {};

                if (geometry.isPointType() || geometry.isMultiPointType()) {

                    /*
                    const v = new WorldWind.PlacemarkAttributes(attr);

                    const amenity = properties.amenity;
                    if (amenity) {
                        if (amenity === 'post_box')
                            v.imageColor = WorldWind.Color.BLUE;
                        else if (amenity === 'bank')
                            v.imageColor = WorldWind.Color.GREEN;
                        else
                            v.imageColor = WorldWind.Color.RED;
                    }
                    //v.imageColor = JSON.toString(properties).hash
                    cfg.attributes = v;

                    if (properties && (properties.name || properties.Name || properties.NAME)) {
                        cfg.name = properties.name || properties.Name || properties.NAME;
                    }
                    // if (properties && properties.POP_MAX) {
                    //     const population = properties.POP_MAX;
                    //     configuration.attributes.imageScale = 0.01 * Math.log(population);
                    // }
                    */
                } else if (geometry.isLineStringType() || geometry.isMultiLineStringType()) {
                    cfg.attributes = new WorldWind.ShapeAttributes(null);
                    cfg.attributes.depthTest = false;
                    cfg.attributes.drawInterior = false;
                    cfg.attributes.drawOutline = true;
                    // cfg.attributes.outlineWidth = 2;
                    // cfg.attributes.outlineColor = new WorldWind.Color(
                    //     0.375 + 0.5 * Math.random(),
                    //     0.375 + 0.5 * Math.random(),
                    //     0.375 + 0.5 * Math.random(),
                    //     0.9);
                } else if (geometry.isPolygonType() || geometry.isMultiPolygonType()) {
                    cfg.attributes = new WorldWind.ShapeAttributes(null);
                    //cfg.attributes.depthTest = false;
                    cfg.attributes.drawOutline = false;
                    // Fill the polygon with a random pastel color.
                    cfg.attributes.interiorColor = new WorldWind.Color(
                        0.375 + 0.5 * Math.random(),
                        0.375 + 0.5 * Math.random(),
                        0.375 + 0.5 * Math.random(),
                        1);
                    // Paint the outline in a darker variant of the interior color.
                    // configuration.attributes.outlineColor = new WorldWind.Color(
                    //     0.5 * configuration.attributes.interiorColor.red,
                    //     0.5 * configuration.attributes.interiorColor.green,
                    //     0.5 * configuration.attributes.interiorColor.blue,
                    //     1.0);
                }

                return cfg;
            };


        }


        update(query, lat, lon, latHalf, lonHalf) {
            if (!lonHalf)
                lonHalf = latHalf; //TODO based on latitude


            const latMin = lat - latHalf, latMax = lat + latHalf;
            const lonMin = lon - lonHalf, lonMax = lon + lonHalf;

            //dither these numbers to maximize cache hit rates:
            const bbox = this.bbox(
                _.round(latMin, 3), _.round(lonMin, 3),
                _.round(latMax, 3), _.round(lonMax, 3));

            $.ajax({
                url:
                    //'https://overpass.openstreetmap.fr/api/interpreter'
                    //'https://overpass-api.de/api/interpreter'
                    'https://lz4.overpass-api.de/api/interpreter'
                    //'https://z.overpass-api.de/api/interpreter'
                    + '?data=' + encodeURIComponent(
                        '[out:json];\n' + query.replaceAll('<bbox>', bbox) + '\nout geom' + bbox + ';'
                    ),
                contentType: 'application/json',
                dataType: 'json',
                headers: {
                    "Accepts": "text/plain; charset=utf-8",
                    "Cache-Control": 'max-age=3600'//<seconds>
                }
            }).done(X => this._load(X));
        }

        bbox(latMin, lonMin, latMax, lonMax) {
            return '(' + latMin + ',' + lonMin + ',' + latMax + ',' + lonMax + ')';
        }

        _load(X) {
            const x = osmtogeojson(X);
            const features = _.filter(x.features, (z)=>{
                return z.properties.amenity || (z.geometry.type==='Polygon' ||z.geometry.type==='LineString');
            });
            _.forEach(features, f => this.load(f));
        }

        load(x) {

            const interests = [];
            {
                //register inferred interests
                const pp = x.properties;
                // if (pp.amenity) interests.push(pp.amenity);
                // if (pp.highway) interests.push('Way');
                // if (pp.power) interests.push('Power');
                // if (pp.boundary) interests.push('Boundary');
                // if (pp.barrier) interests.push('Barrier');
                // if (pp.waterway) interests.push('Water');
                // if (pp.building) interests.push('Building');
                // _.forEach(interests, i => {
                //     this.focus.addInterest(pp.id, i);
                // });
                //console.log(pp);
                const X = pp.id;
                _.forEach(pp, (value, key) => {
                    if (key === 'id' || key === 'name' || key === 'ele' || key.startsWith('addr') || key==='odbl' || key==='layer' || key === 'website' || key === 'source' || key.startsWith('gnis') || key.startsWith('tiger'))
                        return;
                    // this.focus.addInterest(X, key);
                    // this.focus.addInterest(X, value);
                    const keyvalue = key + '=' + value;
                    this.focus.addInterest(X, keyvalue);
                    this.focus.addInterest(keyvalue, key);
                    const xx = this.focus.attn.getElementById(X);
                    xx.data('instance', x);
                    //xx.style('display', 'none');
                });
            }

            const ll = [];
            const p = new WorldWind.GeoJSONParser(x);

            const altitudeDefault = 3.5, altitudeRoad = 2;

            p.addRenderablesForPoint = function (layer, geometry, properties) {
                const cfg = this.shapeConfigurationCallback(geometry, properties);


                if (!(!this.crs || this.crs.isCRSSupported())) return;

                const coords = geometry.coordinates;
                const lon = coords[0],
                    lat = coords[1];
                let alt = coords[2] ? coords[2] : 0;
                alt += 5;
                // var reprojectedCoordinate = this.getReprojectedIfRequired(lat, lon, this.crs);
                // lat = reprojectedCoordinate[1];
                // lon = reprojectedCoordinate[0];
                const w = 0.0001;
                const meshPositions = [];
                for (let lt = lat - w / 2; lt <= lat + w / 2; lt += w) {
                    const row = [];
                    for (let ln = lon - w / 2; ln <= lon + w / 2; ln += w)
                        row.push(new WorldWind.Position(lt, ln, alt));
                    meshPositions.push(row);
                }
                //console.log(meshPositions);
                const icon = new WorldWind.GeographicMesh(meshPositions, cfg);
                let attr = new WorldWind.ShapeAttributes(null);
                attr.concept = properties;
                attr.outlineColor = WorldWind.Color.BLACK;
                attr.interiorColor = new WorldWind.Color(1, 1, 1, 0.75);
                attr.applyLighting = true;
                icon.altitudeMode = WorldWind.RELATIVE_TO_GROUND;
                icon.attributes = attr;
                if (cfg && cfg.name) icon.label = cfg.name;
                if (cfg && cfg.eyeDistanceScaling) icon.eyeDistanceScaling = cfg.eyeDistanceScaling;
                if (cfg && cfg.eyeDistanceScalingThreshold) icon.eyeDistanceScalingThreshold = cfg.eyeDistanceScalingThreshold;
                if (cfg && cfg.imageRotation) icon.imageRotation = cfg.imageRotation;
                if (cfg && cfg.imageRotationReference) icon.imageRotationReference = cfg.imageRotationReference;
                if (cfg && cfg.highlightAttributes) icon.highlightAttributes = cfg.highlightAttributes;
                if (cfg && cfg.pickDelegate) icon.pickDelegate = cfg.pickDelegate;
                if (cfg && cfg.userProperties) icon.userProperties = cfg.userProperties;
                ll.push(icon);
            };

            p.addRenderablesForPolygon = function (layer, geometry, properties) {

                if (!(!this.crs || this.crs.isCRSSupported())) return;

                const cfg = this.shapeConfigurationCallback(geometry, properties);

                const b = [];
                const boundaries = geometry.coordinates;
                for (let boundariesIndex = 0; boundariesIndex < boundaries.length; boundariesIndex++) {
                    const positions = [];
                    const points = boundaries[boundariesIndex];
                    for (let positionIndex = 0; positionIndex < points.length; positionIndex++) {
                        const pp = points[positionIndex];
                        const lon = pp[0], lat = pp[1], alt = pp[2] ? pp[2] : altitudeDefault;
                        const reprojectedCoordinate = this.getReprojectedIfRequired(lat, lon, this.crs);
                        positions.push(new WorldWind.Position(reprojectedCoordinate[1], reprojectedCoordinate[0], alt));
                    }
                    b.push(positions);
                }
                cfg.attributes.concept = properties;
                cfg.attributes.drawOutline = false;
                cfg.attributes.depthTest = true;
                cfg.attributes.drawVerticals = false;
                cfg.attributes.applyLighting = cfg.attributes.enableLighting = false;
                const shape = new WorldWind.Polygon(
                    b,
                    cfg && cfg.attributes ? cfg.attributes : null);
                shape.altitudeMode = WorldWind.RELATIVE_TO_GROUND;
                shape.extrude = true;
                if (properties.name)
                    shape.displayName = properties.name;

                if (cfg && cfg.highlightAttributes) shape.highlightAttributes = cfg.highlightAttributes;
                if (cfg && cfg.pickDelegate) shape.pickDelegate = cfg.pickDelegate;
                if (cfg && cfg.userProperties) shape.userProperties = cfg.userProperties;
                ll.push(shape);
            };
            const that = this;
            p.addRenderablesForLineString = function (layer, geometry, properties) {

                if (!(!this.crs || this.crs.isCRSSupported()))
                    return;

                const cfg = this.shapeConfigurationCallback(geometry, properties);

                const positions = [];
                const points = geometry.coordinates;
                for (let pointsIndex = 0; pointsIndex < points.length; pointsIndex++) {
                    const pp = points[pointsIndex];
                    const lon = pp[0], lat = pp[1], altitude = pp[2] ? pp[2] : altitudeRoad;
                    const reprojectedCoordinate = this.getReprojectedIfRequired(lat, lon, this.crs);
                    positions.push(new WorldWind.Position(reprojectedCoordinate[1], reprojectedCoordinate[0], altitude));
                }
                cfg.attributes.concept = properties;
                cfg.attributes.depthTest = true;
                cfg.attributes.applyLighting = cfg.attributes.enableLighting = false;
                cfg.attributes.drawInterior = true;
                // cfg.attributes.outlineColor =
                //     //undefined;
                //     new WorldWind.Color(1, 0.5, 0, 1);
                cfg.attributes.drawOutline = false;
                //cfg.attributes.outlineWidth = 4;


                var thick = 1;
                var color = undefined;

                //console.log(properties);
                if (properties.footway === 'sidewalk') {
                    thick = 0.5;
                    color = new WorldWind.Color(0.5, 0.5, 0.5, 1);
                }
                if (properties.lanes === '1') {
                    thick = 2;
                    //color = new WorldWind.Color(0.5, 1, 0, 1);
                } else if (properties.lanes === '2') {
                    thick = 4;
                    //color = new WorldWind.Color(0.5, 1, 0, 1);
                } else {

                }

                cfg.attributes.interiorColor = color || new WorldWind.Color(1, 0.5, 0, 1);

                const path =
                    // new WorldWind.Path(
                    //     //new WorldWind.SurfacePolyline(
                    //     positions, cfg.attributes);
                    new WorldWind.Polygon(that.polygonize(positions, thick * 0.00005), cfg.attributes);
                //new WorldWind.SurfacePolygon(that.polygonize(positions), cfg.attributes);

                path.altitudeMode = WorldWind.RELATIVE_TO_GROUND;
                path.followTerrain = true;
                path.extrude = false;
                //path._numSubSegments = 3;
                if (cfg && cfg.highlightAttributes) path.highlightAttributes = cfg.highlightAttributes;
                if (cfg && cfg.pickDelegate) path.pickDelegate = cfg.pickDelegate;
                if (cfg && cfg.userProperties) path.userProperties = cfg.userProperties;
                ll.push(path);
            };

            const yl = this.layer;

            x.renderables = ll;

            p.load(null, this.shapeConfigurationCallback, yl);

            _.forEach(ll, yy => {
                yy.enabled = false;
                return yl.addRenderable(yy);
            });
        }

        polygonize(positions, thick) {
            //TODO better
            const y = [];
            const n = positions.length;
            const theta = Math.atan2(positions[n - 1].longitude - positions[0].longitude, positions[n - 1].latitude - positions[0].latitude);
            const thickHalfX = thick / 2 * Math.cos(theta);
            const thickHalfY = thick / 2 * Math.sin(theta);
            _.forEach(positions, (x) => {
                const xx = _.clone(x);
                xx.longitude -= thickHalfX;
                xx.latitude -= thickHalfY;
                y.push(xx);
            });
            _.forEach(positions, (x) => {
                const xx = _.clone(x);
                xx.longitude += thickHalfX;
                xx.latitude += thickHalfY;
                y.unshift(xx);
            });
            return y;
        }

        stop(focus) {
            _.forEach(this.layers, focus.removeLayer);
            delete this.layers;
        }
    }

    class Focus {

        constructor(view) {
            this.layers = [];

            const _focus = this;
            var attn = this.attn = cytoscape({

                headless : true
                //container: document.getElementById('interests'), // container to render in

                // style: [ // the stylesheet for the graph
                //     // cytoscape.stylesheet().selector('node').style({
                //     //     'background-color': e => e.data('bg')
                //     // }),
                //     // cytoscape.stylesheet().selector('node').style({
                //     //     'visible': e => e.data('instance') ? 'none': null
                //     // }),
                //     {
                //         selector: 'node',
                //         style: {
                //             'background-color': '#666',
                //             'label': 'data(id)'
                //         }
                //     },
                //
                //     {
                //         selector: 'edge',
                //         style: {
                //             'width': 3,
                //             'line-color': '#ccc'
                //             // 'target-arrow-color': '#ccc',
                //             // 'target-arrow-shape': 'triangle',
                //             // 'curve-style': 'bezier'
                //         }
                //     }
                // ]

            });
            //cy.userPanningEnabled(true);
            //cy.boxSelectionEnabled(false);
             //var layout = null;
             attn.attnUpdated = _.debounce(()=> {
            //     cy.startBatch();
            //     if (layout!==null)
            //         layout.stop();
            //
                 const tgt = $('#interests');
                 tgt.html('');

                 const rank = attn.$().pageRank().rank;
                 attn.elements("node").forEach(x=>{
                     if (x.data('instance'))
                         return;

                     const rx = rank(x);
                     const xid = x.id();
                     //console.log(xid, rx);
                     const icon = $('<div>').text(xid).addClass('interest').addClass('buttonlike').attr('style', 'font-size: ' + (Math.min(70,(rx * 2E4)) + 'px'));
                     let goalSelect = $('<select>').append(
                         $('<option>').text('++'),
                         $('<option>').text('+'),
                         $('<option selected>').text(' '),
                         $('<option>').text('-'),
                         $('<option>').text('--')
                     );
                     goalSelect.change(()=>{
                        var dfs = attn.elements().dfs({
                             roots: attn.getElementById(xid),
                             visit: function(v, e, u, i, depth){
                                 //console.log(xid, ' -> ' + v);
                                 const V = v.data('instance');
                                 if (V && V.renderables) {
                                     _.forEach(V.renderables, (vr) => {
                                         vr.enabled = true;
                                         //vr.layer.refresh();
                                     });
                                     _focus.view.redraw();
                                 }

                                 // // example of finding desired node
                                 // if( v.data('weight') > 70 )
                                 //     return true;
                                 // // example of exiting search early
                                 // if( v.data('weight') < 0 )
                                 //     return false;
                             },
                             directed: true
                         });
                     });
                     icon.prepend(goalSelect);
                     tgt.append(icon);
                      // const w = parseInt(rx * 1E5) + 'px';
                      // //console.log(x.id(), x.style('width'), w);
                      // x.style('width', w);
                      // x.style('height', w);
                  });
            //
            //     //console.log('layout');
            //     layout = cy.layout({
            //         //name: 'cose'
            //         //name: 'random'
            //         //name: 'grid'
            //         name: 'breadthfirst'
            //     });
            //     layout.run();
            //     cy.endBatch();
            }, 500);

            this.view = view;

            let anim = null;

            // The common pick-handling function.
            // Listen for mouse moves and highlight the placemarks that the cursor rolls over.
            // Listen for taps on mobile devices and highlight the placemarks that the user taps.
            let finger = o => {
                //console.log(o);
                if (o.buttons !== 1)
                    return;

                //_.forEach(this.touched, t => t.highlighted = false);
                //const touched = this.touched = [];
                let picked;
                try {
                    const px = o.clientX, py = o.clientY;
                    picked = view.pick(view.canvasCoordinates(px, py));
                } catch (e) {
                    console.log(e);
                    return;
                }

                const picks = picked.objects;
                //console.log(picks);

                if (picks.length > 0) {
                    const x = picks[picks.length - 1];
                    //_.forEach(picks, x => {
                    if (x.isTerrain) {
                        //toastr.info("terrain " + x.position);
                    } else {
                        if (anim === null) {

                            const tgt = new WorldWind.Position().copy(x.userObject.referencePosition);
                            tgt.altitude += 100;

                            anim = new WorldWind.GoToAnimator(view);
                            anim.travelTime = 1000;
                            anim.goTo(tgt, () => {
                                anim = null;
                            });
                        }

                        // const concept = x.userObject.userProperties.concept || x.userObject.displayName;
                        // toastr.info(JSON.stringify(concept), {
                        //     closeButton: true
                        // });
                    }
                }
                // _.forEach(picks, p => {
                //     const o = p.userObject;
                //     o.highlighted = true;
                //     touched.push(o);
                // })
                //view.redraw(); // redraw to make the highlighting changes take effect on the screen


            };
            finger = _.debounce(finger, 100);

            //var tapRecognizer = new WorldWind.TapRecognizer(view, finger);
            //view.addEventListener("mousemove", finger);
            view.addEventListener("pointerdown", finger);

            // console.log(view.drawContext);

            // const b = view.drawContext.surfaceShapeTileBuilder;
            // console.log(b);
            //b.detailControl = 2;
            // b.tileWidth = b.tileHeight =
            //     b.levels.tileWidth = b.levels.tileHeight = //HACK
            //     1024;
            //b.clear();


            const updatePeriodMS = 200;
            this.running = setInterval(this.run, updatePeriodMS);
        }

        run() {
            _.forEach(this.layers, x => {
                x.update(this);
            });
        }

        position(lat, lon, alt) {
            const cam = this.cam();
            const pos = cam.position;
            if (lat && lon && alt) {
                //cam.tilt = 45;
                pos.latitude = lat;
                pos.longitude = lon;
                pos.altitude = alt;
            }
            return pos;
        }

        cam() {
            return this.view.camera;
        }

        addInterest(x, y, cfg) {
            // if (this.interests.get(i))
            //     return; //ignore duplicate

            //console.log(x, y);
            this.attn.add([
                { group: 'nodes', data: { id: x } },
                { group: 'nodes', data: { id: y } },
                { group: 'edges', data: { /*id: x + '__' + y,*/ source: y, target: x } }
            ]);

            this.attn.attnUpdated();

            //console.log(this.interests.nodes());
            // if (cfg === undefined) cfg = new Map();
            // this.interests.set(i, cfg);
            // $('#interests').append($('<span>').append(this.interestIcon(i, cfg)), ' ');

        }

        // interestIcon(i, cfg) {
        //     return $('<span>').text(i).addClass('buttonlike').addClass('interestIcon');
        // }

        addLayer(layer) {
            this.layers.push(layer);

            if (layer.enabled === undefined)
                layer.enable(); //default state

            layer.start(this);
        }

        removeLayer(layer) {
            layer.element.remove();
            delete layer.element;

            this.layers = _.filter(this.layers, x => x !== layer);
            //console.log(layer, ' = ? = ', removed); //TODO
            layer.stop(this);
        }

    }


    window.addEventListener("load", () => {

        //console.log(WorldWind.configuration);
        WorldWind.configuration.gpuCacheSize = 1e9; // 1gb
        WorldWind.Logger.setLoggingLevel(WorldWind.Logger.LEVEL_WARNING);


        const w = new WorldWind.WorldWindow("map");
        //console.log(w);
        //w.deepPicking = true;
        w.camera.fieldOfView =
            //15;
            //25;
            40;
        //60;

        const f = new Focus(w);
        //TODO w.clearLayers()
        f.addLayer(new HomeLayer());
        f.addLayer(new WWLayer("Atmosphere", new WorldWind.AtmosphereLayer()).disable());
        f.addLayer(new WWLayer("View Controls", new WorldWind.ViewControlsLayer(w)).disable());
        //view.addLayer(new WorldWind.CompassLayer());
        //view.addLayer(new WorldWind.CoordinatesDisplayLayer(wwd));

        // let pos = f.position(
        //     //40.7638, -73.98584, 1000
        //     46.232321, 6.0505552, 1000
        // );  //central park

        const shapeFileOutlineLoader = (attributes, record) => {
            const cfg = {};
            cfg.name = attributes.values.name || attributes.values.Name || attributes.values.NAME;

            if (record.isPointType()) { // Configure point-based features (cities, in this example)
                cfg.name = attributes.values.name || attributes.values.Name || attributes.values.NAME;
                cfg.attributes = new WorldWind.PlacemarkAttributes(placemarkAttributes);

            } else if (record.isPolygonType()) { // Configure polygon-based features (countries, in this example).
                cfg.attributes = new WorldWind.ShapeAttributes(null);
                cfg.attributes.drawInterior = false;
                cfg.attributes.outlineWidth = 10;
                cfg.attributes.outlineColor = new WorldWind.Color(
                    0.375 + 0.5 * Math.random(),
                    0.375 + 0.5 * Math.random(),
                    0.375 + 0.5 * Math.random(),
                    1.0);
            }
            //TODO other shape types
            return cfg;
        };
        const countriesLayer = new WorldWind.RenderableLayer("Countries");
        new WorldWind.Shapefile(
            "https://worldwind.arc.nasa.gov/web/examples/data/shapefiles/naturalearth" +
            "/ne_110m_admin_0_countries/ne_110m_admin_0_countries.shp"
        ).load(null, shapeFileOutlineLoader, countriesLayer);
        f.addLayer(new WWLayer("Countries", countriesLayer).disable());

        // const cityLayer = new WorldWind.RenderableLayer("Cities");
        // const cityShapefile = new WorldWind.Shapefile(shapefileLibrary + "/ne_50m_populated_places_simple/ne_50m_populated_places_simple.shp");
        // cityShapefile.load(null, shapeConfigurationCallback, cityLayer);
        // wwd.addLayer(cityLayer);

        f.addLayer(new WWLayer("OSM", new WorldWind.OpenStreetMapImageLayer())/*.opacity(0.5)*/);
        f.addLayer(new WWLayer("Satellite", new WorldWind.BingAerialWithLabelsLayer()).disable());
        //f.addLayer(new WWLayer("BMGNOne", new WorldWind.BMNGOneImageLayer()).disable());

        // new OSMNodes(f).update('node[amenity]<bbox>;',
        //     pos.latitude, pos.longitude, (40.78568 - 40.7638) / 2);

        const pos = f.position();
        //console.log(pos);
        const osm = new OSMNodes(f);
        osm.update(
            '(way<bbox>; node<bbox>;);'
            //'(way[highway]<bbox>; relation<bbox>; node<bbox>;);'
            , pos.latitude, pos.longitude, 0.007)

        $("#side_toggle").click(() => {
            const body = document.body;
            if (body.classList.contains('sideExpanded')) {
                body.classList.remove('sideExpanded');
            } else {
                body.classList.add('sideExpanded');
            }
        });
        $("#addmenu_toggle").click(() => {
            $("#addmenu").toggle(/*"slow"*/);
        });

        // {
        //     $.ajax({
        //         url: 'osm.tags.popular.json',
        //     }).done(tags => {
        //         const raw = $('#mode_raw');
        //        _.forEach(tags.data, tag=>{
        //            const key = tag.key, value = tag.value;
        //
        //            //filters
        //            if (key === 'source' || key === 'source_ref' || key === 'import_uuid'
        //                || key === 'FIXME' || key === 'fixme' || key === 'start_date' || key === 'gauge' || key === 'note'
        //                || key === 'attribution' || key === 'mapper'
        //            )
        //                return;
        //
        //            raw.append($('<button>').append(key + '=' + value));
        //        });
        //     });
        // }


        // var cy = cytoscape({
        //
        //     container: document.getElementById('root'), // container to render in
        //
        //     elements: [ // list of graph elements to start with
        //         {data: { id: 'fuck' }},
        //         {data: { id: 'shit' }},
        //         {data: { id: 'play' }},
        //         {data: { id: 'sleep' }},
        //         {data: { id: 'eat' }}
        //         /*,
        //         {
        //             data: { id: 'ab', source: 'a', target: 'b' }
        //         }*/
        //     ],
        //
        //     style: [ // the stylesheet for the graph
        //         {
        //             selector: 'node',
        //             style: {
        //                 'background-color': '#666',
        //                 'label': 'data(id)'
        //             }
        //         },
        //
        //         {
        //             selector: 'edge',
        //             style: {
        //                 'width': 3,
        //                 'line-color': '#ccc',
        //                 'target-arrow-color': '#ccc',
        //                 'target-arrow-shape': 'triangle',
        //                 'curve-style': 'bezier'
        //             }
        //         }
        //     ],
        //
        //     layout: {
        //         name: 'cose',
        //         rows: 2
        //     }
        //
        // });
        // cy.userPanningEnabled( false );
        // cy.boxSelectionEnabled( false );
        // cy.removeListener('tap');

    }, false);

</script>
</body>
</html>
